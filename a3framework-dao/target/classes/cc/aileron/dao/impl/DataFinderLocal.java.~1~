/**
 * 
 */
package cc.aileron.dao.impl;

import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import cc.aileron.dao.DataFinder;
import cc.aileron.dao.DataFinderRange;
import cc.aileron.dao.DataTransaction;
import cc.aileron.dao.jdbc.ResultSetHandller;
import cc.aileron.dao.jdbc.SqlTemplateCategory;
import cc.aileron.dao.jdbc.SqlTemplateFetcher;
import cc.aileron.dao.jdbc.StatmentExecutor;
import cc.aileron.dao.jdbc.StatmentLogger;
import cc.aileron.dao.jdbc.StatmentParameter;
import cc.aileron.generic.ObjectContainer;
import cc.aileron.generic.ObjectReference;
import cc.aileron.generic.util.SkipList;
import cc.aileron.pojo.NoSuchPropertyException;
import cc.aileron.pojo.PojoAccessor;
import cc.aileron.pojo.PojoAccessorRepository;

/**
 * @author aileron
 * @param <T>
 */
public class DataFinderLocal<T> implements DataFinder<T>
{
    /**
     * object に fetch させないカラム名に付与する為のプレフィックス
     */
    static final char UNSET_COLUMN_MARKER_PREFIX = '#';

    @Override
    public void bind(final T object)
    {
        final PojoAccessor<T> accessor = repository.from(object);
        statment.execute(fetcher.fetch(SqlTemplateCategory.FIND_ONE, parameter),
                new ResultSetHandller()
                {
                    @Override
                    public void handle(final ResultSet rs)
                            throws SQLException, InvocationTargetException,
                            NoSuchPropertyException
                    {
                        final String[] meta = getMeta(rs.getMetaData());
                        if (!rs.next())
                        {
                            return;
                        }
                        for (int i = 1, size = meta.length; i < size; i++)
                        {
                            final String key = meta[i];
                            if (key.charAt(0) == UNSET_COLUMN_MARKER_PREFIX)
                            {
                                continue;
                            }
                            final Object val = rs.getObject(i);
                            accessor.to(key).set(val);
                        }
                    }
                });
    }

    @Override
    public int count()
    {
        final ObjectContainer<Integer> c = new ObjectContainer<Integer>(0);
        statment.execute(fetcher.fetch(SqlTemplateCategory.COUNT, parameter),
                new ResultSetHandller()
                {
                    @Override
                    public void handle(final ResultSet rs)
                            throws SQLException, InvocationTargetException,
                            NoSuchPropertyException
                    {
                        if (rs.next())
                        {
                            c.value = rs.getInt(1);
                        }
                    }
                });
        return c.value;
    }

    @Override
    public Iterator<T> iterator()
    {
        final StatmentParameter fetch = fetcher.fetch(SqlTemplateCategory.FIND,
                parameter);
        final Connection connection = transaction.get();
        final ResultSet rs;
        final String[] meta;
        try
        {
            final String sql = fetch.sql();
            final List<Object> fetchParameter = fetch.arguments();

            if (logger.isEnable())
            {
                logger.output(fetch);
            }

            final PreparedStatement statement = connection.prepareStatement(sql,
                    java.sql.ResultSet.TYPE_FORWARD_ONLY,
                    java.sql.ResultSet.CONCUR_READ_ONLY);

            for (int max = fetchParameter.size(), i = 0; i < max; i++)
            {
                statement.setObject(i + 1, fetchParameter.get(i));
            }
            if (!statement.execute())
            {
                statement.close();
                return Collections.<T> emptyList().iterator();
            }
            rs = statement.getResultSet();
            meta = getMeta(rs.getMetaData());
            if (!rs.next())
            {
                return Collections.<T> emptyList().iterator();
            }
        }
        catch (final Exception e)
        {
            transaction.end();
            throw new Error(e);
        }

        final PojoAccessor<T> accessor = instance.get();
        final T object;
        try
        {
            object = get(rs, meta, accessor);
        }
        catch (final SQLException e)
        {
            transaction.end();
            throw new Error(e);
        }
        catch (final InvocationTargetException e)
        {
            transaction.end();
            throw new Error(e.getCause());
        }
        catch (final NoSuchPropertyException e)
        {
            transaction.end();
            throw new Error(e);
        }
        return new Iterator<T>()
        {
            @Override
            public boolean hasNext()
            {
                return next != null;
            }

            @Override
            public T next()
            {
                final T result = next;
                try
                {
                    next = get(rs, meta, accessor);
                }
                catch (final SQLException e)
                {
                    transaction.end();
                    throw new Error(e);
                }
                catch (final InvocationTargetException e)
                {
                    transaction.end();
                    throw new Error(e.getCause());
                }
                catch (final NoSuchPropertyException e)
                {
                    transaction.end();
                    throw new Error(e);
                }
                return result;
            }

            @Override
            public void remove()
            {
                throw new UnsupportedOperationException();
            }

            T next = object;
        };
    }

    @Override
    public List<T> list()
    {
        final SkipList<T> result = new SkipList<T>();
        statment.execute(fetcher.fetch(SqlTemplateCategory.FIND, parameter),
                new ResultSetHandller()
                {
                    @Override
                    public void handle(final ResultSet rs)
                            throws SQLException, InvocationTargetException,
                            NoSuchPropertyException
                    {
                        bind(rs, result);
                    }
                });
        return result;
    }

    @Override
    public List<T> list(final DataFinderRange paging)
    {
        final SkipList<T> result = new SkipList<T>();
        statment.execute(fetcher.fetch(SqlTemplateCategory.FIND_PAGING,
                parameter.add(paging)), new ResultSetHandller()
        {
            @Override
            public void handle(final ResultSet rs)
                    throws SQLException, InvocationTargetException,
                    NoSuchPropertyException
            {
                bind(rs, result);
            }
        });
        return result;
    }

    @Override
    public T one()
    {
        final SkipList<T> result = new SkipList<T>();
        statment.execute(fetcher.fetch(SqlTemplateCategory.FIND_ONE, parameter),
                new ResultSetHandller()
                {
                    @Override
                    public void handle(final ResultSet rs)
                            throws SQLException, InvocationTargetException,
                            NoSuchPropertyException
                    {
                        bind(rs, result);
                    }
                });
        if (result.isEmpty())
        {
            return null;
        }
        return result.get(0);
    }

    /**
     * @param rs
     * @param meta
     * @return T
     * @throws SQLException
     * @throws InvocationTargetException
     * @throws NoSuchPropertyException
     */
    List<T> bind(final ResultSet rs, final List<T> result)
            throws SQLException, InvocationTargetException,
            NoSuchPropertyException
    {
        final String[] meta = getMeta(rs.getMetaData());
        while (rs.next())
        {
            final PojoAccessor<T> object = instance.get();
            for (int i = 1, size = meta.length; i < size; i++)
            {
                final String key = meta[i];
                if (key.charAt(0) == UNSET_COLUMN_MARKER_PREFIX)
                {
                    continue;
                }
                final Object val = rs.getObject(i);
                object.to(key).set(val);
            }
            result.add(object.target());
        }
        return result;
    }

    T get(final ResultSet rs, final String[] meta,
            final PojoAccessor<T> accessor)
            throws SQLException, InvocationTargetException,
            NoSuchPropertyException
    {
        for (int i = 1, size = meta.length; i < size; i++)
        {
            final String key = meta[i];
            if (key.charAt(0) == UNSET_COLUMN_MARKER_PREFIX)
            {
                continue;
            }
            final Object val = rs.getObject(i);
            accessor.to(key).set(val);
        }
        return accessor.target();
    }

    /**
     * @param resultSet
     * @return ラベルの集合
     * @throws SQLException
     */
    String[] getMeta(final ResultSetMetaData meta) throws SQLException
    {
        final int count = meta.getColumnCount() + 1;
        final String[] result = new String[count];
        for (int i = 1; i < count; i++)
        {
            result[i] = meta.getColumnLabel(i);
        }
        return result;
    }

    /**
     * @param isCache
     * @param parameter
     * @param repository
     * @param instance
     * @param fetcher
     * @param statmentExecutor
     * @param transaction
     * @param logger
     */
    public DataFinderLocal(final boolean isCache,
            final PojoAccessorRepository repository,
            final ObjectReference<T> instance,
            final SqlTemplateFetcher fetcher,
            final StatmentExecutor statmentExecutor,
            final DataTransaction transaction, final StatmentLogger logger,
            final PojoAccessor<?> parameter)
    {
        this.isCacheable = isCache;
        this.statment = statmentExecutor;
        this.transaction = transaction;
        this.logger = logger;
        this.parameter = parameter;
        this.repository = repository;
        this.instance = new ObjectReference<PojoAccessor<T>>()
        {
            @Override
            public PojoAccessor<T> get()
            {
                return repository.from(instance.get());
            }
        };
        this.fetcher = fetcher;
    }

    final SqlTemplateFetcher fetcher;

    final ObjectReference<PojoAccessor<T>> instance;
    final boolean isCacheable;
    final PojoAccessor<?> parameter;
    final PojoAccessorRepository repository;
    final StatmentExecutor statment;
    final DataTransaction transaction;
    private final StatmentLogger logger;
}
